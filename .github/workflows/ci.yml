name: CI

on:
  push:
    branches: ['master']
  pull_request:
    branches: ['master']

jobs:
  test:
    runs-on: ubuntu-latest
    outputs:
      sha_short: ${{ steps.vars.outputs.sha_short }}
    steps:
      - uses: actions/checkout@v4
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: 'npm'
      - name: Install dependencies
        run: npm install --legacy-peer-deps
      - name: Run unit tests
        run: npm test
      - name: Extract short SHA
        id: vars
        run: echo "sha_short=$(git rev-parse --short HEAD)" >> "$GITHUB_OUTPUT"

  test-production-docker:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build production Docker image
        run: docker build -f Dockerfile.prod -t andy-grails-frontend-prod-test .
      - name: Start production services
        run: |
          # Clean up any existing containers and networks to avoid port conflicts
          echo "Cleaning up any existing containers..."
          docker compose -f docker-compose-prod.yml down -v --remove-orphans 2>/dev/null || true
          docker stop $(docker ps -q) 2>/dev/null || true
          docker rm $(docker ps -aq) 2>/dev/null || true
          docker system prune -f

          # Start the production stack
          docker compose -f docker-compose-prod.yml up -d
      - name: Test production frontend
        run: |
          # Check if the frontend is responding
          echo "Testing frontend accessibility..."
          for i in {1..10}; do
            if curl -f http://localhost:4200/ > /dev/null 2>&1; then
              echo "‚úÖ Frontend is accessible"
              break
            else
              echo "Attempt $i: Frontend not ready yet, waiting..."
              sleep 5
            fi
          done
          # Final check - if this fails, the test fails
          curl -f http://localhost:4200/ || (echo "‚ùå Frontend test failed" && exit 1)
      - name: Check frontend content
        run: |
          # Verify that the Angular app is actually served with proper content
          echo "Testing Angular app content..."

          # Check main page loads Angular app
          response=$(curl -s http://localhost:4200/)
          if echo "$response" | grep -q "andy.grails.frontend\|Angular\|app-root"; then
            echo "‚úÖ Frontend serves Angular application"
          else
            echo "‚ùå Frontend does not serve expected Angular content"
            echo "Response preview: ${response:0:200}..."
            exit 1
          fi

          # Check that assets are accessible
          echo "Testing asset accessibility..."
          if curl -f http://localhost:4200/assets/logo.svg > /dev/null 2>&1; then
            echo "‚úÖ Assets are accessible"
          else
            echo "‚ùå Assets are not accessible"
            exit 1
          fi

          # Check that the app loads without JavaScript errors (basic check)
          echo "Testing JavaScript bundle..."
          if curl -s http://localhost:4200/ | grep -q "main-"; then
            echo "‚úÖ JavaScript bundle is referenced"
          else
            echo "‚ùå JavaScript bundle not found"
            exit 1
          fi

          # Install Puppeteer for headless browser testing
          echo "Installing Puppeteer for JavaScript-enabled testing..."
          npm install puppeteer

          # Wait for Angular app to load and render content using headless browser
          echo "Waiting for Angular app to load and render video content..."
          node -e "
          const puppeteer = require('puppeteer');

          (async () => {
            const browser = await puppeteer.launch({ 
              headless: true,
              args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-accelerated-2d-canvas',
                '--no-first-run',
                '--no-zygote',
                '--single-process',
                '--disable-gpu'
              ]
            });
            const page = await browser.newPage();
            
            try {
              console.log('Loading page...');
              await page.goto('http://localhost:4200', { waitUntil: 'networkidle2', timeout: 30000 });
              
              console.log('Waiting for Angular app to render...');
              await page.waitForSelector('app-root', { timeout: 10000 });
              
              console.log('Waiting for video content to load...');
              for (let i = 1; i <= 5; i++) {
                console.log(\`Attempt \${i}: Checking for video content...\`);
                
                try {
                  await page.waitForFunction(
                    () => document.body.textContent.includes('J. S. Bach - Bourr√©e'),
                    { timeout: 5000 }
                  );
                  console.log('‚úÖ Video \"J. S. Bach - Bourr√©e\" is displayed on the page');
                  break;
                } catch (error) {
                  if (i === 15) {
                    const content = await page.content();
                    console.log('‚ùå Video \"J. S. Bach - Bourr√©e\" not found after 15 attempts');
                    console.log('Page content preview:', content.substring(0, 1000));
                    process.exit(1);
                  }
                  console.log('Video not found yet, waiting 5 seconds...');
                  await new Promise(resolve => setTimeout(resolve, 5000));
                }
              }
            } catch (error) {
              console.error('Error during testing:', error.message);
              process.exit(1);
            } finally {
              await browser.close();
            }
          })();
          "
      - name: Cleanup
        if: always()
        run: docker compose -f docker-compose-prod.yml down -v

  publish_to_docker_hub:
    runs-on: ubuntu-latest
    needs: [test, test-production-docker]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    steps:
      - uses: actions/checkout@v4
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: andygrails
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.prod
          push: true
          tags: |
            andygrails/andy-grails-frontend:latest
            andygrails/andy-grails-frontend:${{ needs.test.outputs.sha_short }}
      - name: Confirm Docker image is on Docker Hub
        run: |
          echo "üîç Verifying Docker image exists on Docker Hub by pulling it..."
          docker pull andygrails/andy-grails-frontend:${{ needs.test.outputs.sha_short }} \
            && echo "‚úÖ Docker image pulled successfully." \
            || (echo "‚ùå Failed to pull Docker image." && exit 1)

  update_parent_repo:
    runs-on: ubuntu-latest
    needs: publish_to_docker_hub
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    steps:
      - name: Trigger parent repo to update submodule
        run: |
          set -e  # Fail the job if any command fails
          # Prepare the JSON payload
          PAYLOAD=$(cat <<EOF
          {
            "event_type": "update_frontend_rev",
            "client_payload": {
              "frev": "${{ github.sha }}",
              "ref": "refs/heads/master"
            }
          }
          EOF
          )
          echo "PAYLOAD: $PAYLOAD"
          # Send the API request
            RESPONSE=$(curl -w "%{http_code}" -X POST https://api.github.com/repos/aistomin/andy.grails/dispatches \
              -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "$PAYLOAD")
          # Get the HTTP status code
          HTTP_CODE=$(echo "$RESPONSE" | tail -n 1)  # Get the last line, which is the HTTP response code
          if [[ "$HTTP_CODE" -ne 200 ]] && [[ "$HTTP_CODE" -ne 204 ]]; then
            echo "‚ùå Error: Received HTTP status code $HTTP_CODE from GitHub API:"
            echo $RESPONSE
            exit 1  # Force the job to fail
          else
            echo "‚úÖ GitHub API call was successful with HTTP status code: $HTTP_CODE"  
          fi
